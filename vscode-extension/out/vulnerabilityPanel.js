"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulnerabilityPanel = void 0;
const vscode = __importStar(require("vscode"));
class VulnerabilityPanel {
    constructor(panel, apiClient) {
        this.apiClient = apiClient;
        this.disposables = [];
        this.panel = panel;
        this.panel.onDidDispose(() => this.dispose(), null, this.disposables);
        this.panel.webview.onDidReceiveMessage(async (message) => {
            switch (message.command) {
                case 'applyFix':
                    await this.applyFix(message.finding);
                    break;
                case 'applyAndCommit':
                    await this.applyFixAndCommit(message.finding);
                    break;
            }
        }, null, this.disposables);
    }
    static show(finding, apiClient) {
        const column = vscode.window.activeTextEditor
            ? vscode.window.activeTextEditor.viewColumn
            : undefined;
        if (VulnerabilityPanel.currentPanel) {
            VulnerabilityPanel.currentPanel.panel.reveal(column);
            VulnerabilityPanel.currentPanel.update(finding);
        }
        else {
            const panel = vscode.window.createWebviewPanel('vulnerabilityDetails', 'Vulnerability Details', column || vscode.ViewColumn.Two, {
                enableScripts: true,
                retainContextWhenHidden: true
            });
            VulnerabilityPanel.currentPanel = new VulnerabilityPanel(panel, apiClient);
            VulnerabilityPanel.currentPanel.update(finding);
        }
    }
    update(finding) {
        this.panel.title = finding.title;
        this.panel.webview.html = this.getHtmlContent(finding);
    }
    async applyFix(finding) {
        if (!finding.remediation_code) {
            vscode.window.showWarningMessage('No remediation code available');
            return;
        }
        try {
            const document = await vscode.workspace.openTextDocument(finding.file);
            await vscode.window.showTextDocument(document);
            const edit = new vscode.WorkspaceEdit();
            const line = Math.max(0, (finding.line || 1) - 1);
            const range = new vscode.Range(line, 0, line + 1, 0);
            edit.replace(document.uri, range, finding.remediation_code + '\n');
            const success = await vscode.workspace.applyEdit(edit);
            if (success) {
                vscode.window.showInformationMessage('Fix applied successfully!');
            }
        }
        catch (error) {
            vscode.window.showErrorMessage('Failed to apply fix: ' + error.message);
        }
    }
    async applyFixAndCommit(finding) {
        await this.applyFix(finding);
        const terminal = vscode.window.createTerminal('AppSec Auto-Remediation');
        terminal.show();
        const commitMsg = 'fix: ' + finding.title + '\n\nAuto-remediated by AppSec AI Scanner';
        terminal.sendText('git add "' + finding.file + '"');
        terminal.sendText('git commit -m "' + commitMsg + '"');
        vscode.window.showInformationMessage('Fix applied and committed to git!');
    }
    getHtmlContent(finding) {
        const severityColors = {
            'critical': '#dc2626',
            'high': '#ea580c',
            'medium': '#f59e0b',
            'low': '#10b981'
        };
        const severityColor = severityColors[finding.severity.toLowerCase()] || '#6b7280';
        const impacts = this.getImpactItems(finding);
        const steps = this.getRemediationSteps(finding);
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vulnerability Details</title>
    <style>
        body { font-family: sans-serif; padding: 20px; line-height: 1.6; }
        .header { border-bottom: 2px solid ` + severityColor + `; padding-bottom: 15px; }
        .severity-badge { padding: 4px 12px; border-radius: 12px; background: ` + severityColor + `; color: white; font-weight: bold; }
        .section { margin: 20px 0; padding: 15px; border-left: 3px solid ` + severityColor + `; }
        .btn { padding: 10px 20px; margin: 5px; border: none; border-radius: 4px; cursor: pointer; }
        .btn-primary { background: #0078d4; color: white; }
        .btn-success { background: #10b981; color: white; }
    </style>
</head>
<body>
    <div class="header">
        <h1>` + finding.title + `</h1>
        <span class="severity-badge">` + finding.severity + `</span>
        <p><strong>File:</strong> ` + finding.file + `:` + String(finding.line) + `</p>
    </div>
    <div class="section">
        <h3>Description</h3>
        <p>` + finding.description + `</p>
    </div>
    <div class="section">
        <h3>Impact</h3>
        <ul>` + impacts.map(i => '<li>' + i + '</li>').join('') + `</ul>
    </div>
    <div class="section">
        <h3>Remediation Steps</h3>
        <ol>` + steps.map(s => '<li>' + s + '</li>').join('') + `</ol>
    </div>
    ` + (finding.remediation_code ? `
    <div class="section">
        <h3>Suggested Fix</h3>
        <pre>` + this.escapeHtml(finding.remediation_code) + `</pre>
        <button class="btn btn-primary" onclick="applyFix()">Apply Fix</button>
        <button class="btn btn-success" onclick="applyAndCommit()">Apply & Commit</button>
    </div>` : '') + `
    <script>
        const vscode = acquireVsCodeApi();
        function applyFix() { vscode.postMessage({command: 'applyFix', finding: ` + JSON.stringify(finding) + `}); }
        function applyAndCommit() { vscode.postMessage({command: 'applyAndCommit', finding: ` + JSON.stringify(finding) + `}); }
    </script>
</body>
</html>`;
    }
    escapeHtml(text) {
        return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    getImpactItems(finding) {
        if (finding.impact) {
            return [finding.impact];
        }
        const impactMap = {
            'critical': [
                'Remote code execution possible',
                'Complete system compromise',
                'Data breach and unauthorized access',
                'Immediate action required'
            ],
            'high': [
                'Significant security risk',
                'Potential data exposure',
                'Authentication/authorization bypass possible',
                'Exploitation likely'
            ],
            'medium': [
                'Security weakness present',
                'Could be chained with other vulnerabilities',
                'Increases attack surface',
                'Should be addressed soon'
            ],
            'low': [
                'Minor security concern',
                'Limited exploitability',
                'Good security practice to fix',
                'Low priority remediation'
            ]
        };
        return impactMap[finding.severity.toLowerCase()] || ['Potential security vulnerability', 'Could be exploited by attackers', 'May compromise application security'];
    }
    getRemediationSteps(finding) {
        if (finding.remediation_steps && finding.remediation_steps.length > 0) {
            return finding.remediation_steps;
        }
        if (finding.remediation) {
            return finding.remediation.split('\n').filter((s) => s.trim());
        }
        return [
            'Review the vulnerable code at ' + finding.file + ':' + finding.line,
            'Understand the security implications',
            'Apply the suggested fix or implement custom remediation',
            'Test the changes thoroughly',
            'Run security scan again to verify the fix',
            'Commit the changes to your repository'
        ];
    }
    dispose() {
        VulnerabilityPanel.currentPanel = undefined;
        this.panel.dispose();
        while (this.disposables.length) {
            const disposable = this.disposables.pop();
            if (disposable) {
                disposable.dispose();
            }
        }
    }
}
exports.VulnerabilityPanel = VulnerabilityPanel;
//# sourceMappingURL=vulnerabilityPanel.js.map