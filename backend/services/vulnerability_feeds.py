"""
Live Vulnerability Feeds Integration

Integrates with multiple vulnerability databases for real-time security data:
- GitHub Advisory Database (GHSA)
- OSV (Open Source Vulnerabilities)
- Snyk Vulnerability Database

Provides unified interface for querying vulnerabilities across all sources.
"""

import os
import asyncio
import httpx
from typing import List, Dict, Any, Optional, Set
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
import json
import logging

logger = logging.getLogger(__name__)


class VulnerabilitySource(Enum):
    GITHUB_ADVISORY = "github_advisory"
    OSV = "osv"
    SNYK = "snyk"
    NVD = "nvd"
    LOCAL = "local"


@dataclass
class VulnerabilityRecord:
    """Unified vulnerability record from any source"""
    id: str
    source: VulnerabilitySource
    package_name: str
    ecosystem: str
    affected_versions: List[str]
    fixed_versions: List[str]
    severity: str
    cvss_score: Optional[float]
    cvss_vector: Optional[str]
    cve_ids: List[str]
    cwe_ids: List[str]
    title: str
    description: str
    published_date: Optional[str]
    modified_date: Optional[str]
    references: List[str]
    aliases: List[str] = field(default_factory=list)


class GitHubAdvisoryClient:
    """
    Client for GitHub Advisory Database (GHSA)

    Uses the GitHub GraphQL API to query security advisories.
    Requires a GitHub personal access token with read:packages scope.
    """

    GRAPHQL_ENDPOINT = "https://api.github.com/graphql"

    def __init__(self, token: Optional[str] = None):
        self.token = token or os.getenv("GITHUB_TOKEN", "")
        self._cache: Dict[str, List[VulnerabilityRecord]] = {}
        self._cache_time: Dict[str, datetime] = {}
        self._cache_duration = timedelta(hours=1)

    async def get_advisories_for_package(
        self,
        package_name: str,
        ecosystem: str
    ) -> List[VulnerabilityRecord]:
        """
        Fetch security advisories for a specific package from GitHub Advisory Database.

        Args:
            package_name: Name of the package
            ecosystem: Package ecosystem (npm, pip, maven, etc.)

        Returns:
            List of VulnerabilityRecord objects
        """
        cache_key = f"{ecosystem}:{package_name}"

        # Check cache
        if cache_key in self._cache:
            cache_time = self._cache_time.get(cache_key)
            if cache_time and datetime.now() - cache_time < self._cache_duration:
                return self._cache[cache_key]

        if not self.token:
            logger.warning("GitHub token not configured, skipping GitHub Advisory lookup")
            return []

        # Map ecosystems to GitHub ecosystem names
        ecosystem_map = {
            "npm": "NPM",
            "pip": "PIP",
            "maven": "MAVEN",
            "gradle": "MAVEN",
            "composer": "COMPOSER",
            "bundler": "RUBYGEMS",
            "go": "GO",
            "cargo": "RUST",
            "nuget": "NUGET",
        }

        gh_ecosystem = ecosystem_map.get(ecosystem.lower())
        if not gh_ecosystem:
            return []

        query = """
        query($ecosystem: SecurityAdvisoryEcosystem!, $package: String!) {
            securityVulnerabilities(
                first: 100,
                ecosystem: $ecosystem,
                package: $package
            ) {
                nodes {
                    advisory {
                        ghsaId
                        summary
                        description
                        severity
                        cvss {
                            score
                            vectorString
                        }
                        identifiers {
                            type
                            value
                        }
                        cwes(first: 10) {
                            nodes {
                                cweId
                            }
                        }
                        references {
                            url
                        }
                        publishedAt
                        updatedAt
                    }
                    package {
                        name
                        ecosystem
                    }
                    vulnerableVersionRange
                    firstPatchedVersion {
                        identifier
                    }
                }
            }
        }
        """

        variables = {
            "ecosystem": gh_ecosystem,
            "package": package_name
        }

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    self.GRAPHQL_ENDPOINT,
                    headers={
                        "Authorization": f"Bearer {self.token}",
                        "Content-Type": "application/json"
                    },
                    json={"query": query, "variables": variables}
                )

                if response.status_code != 200:
                    logger.error(f"GitHub API error: {response.status_code}")
                    return []

                data = response.json()

                if "errors" in data:
                    logger.error(f"GitHub GraphQL errors: {data['errors']}")
                    return []

                vulnerabilities = data.get("data", {}).get("securityVulnerabilities", {}).get("nodes", [])

                records = []
                for vuln in vulnerabilities:
                    advisory = vuln.get("advisory", {})

                    # Extract CVE IDs
                    cve_ids = [
                        id_obj["value"]
                        for id_obj in advisory.get("identifiers", [])
                        if id_obj.get("type") == "CVE"
                    ]

                    # Extract CWE IDs
                    cwe_ids = [
                        node["cweId"]
                        for node in advisory.get("cwes", {}).get("nodes", [])
                    ]

                    # Extract references
                    references = [
                        ref["url"]
                        for ref in advisory.get("references", [])
                    ]

                    # Map severity
                    severity_map = {
                        "CRITICAL": "critical",
                        "HIGH": "high",
                        "MODERATE": "medium",
                        "LOW": "low"
                    }

                    cvss_data = advisory.get("cvss", {})

                    record = VulnerabilityRecord(
                        id=advisory.get("ghsaId", ""),
                        source=VulnerabilitySource.GITHUB_ADVISORY,
                        package_name=vuln.get("package", {}).get("name", package_name),
                        ecosystem=ecosystem,
                        affected_versions=[vuln.get("vulnerableVersionRange", "")],
                        fixed_versions=[vuln.get("firstPatchedVersion", {}).get("identifier", "")] if vuln.get("firstPatchedVersion") else [],
                        severity=severity_map.get(advisory.get("severity", ""), "medium"),
                        cvss_score=cvss_data.get("score") if cvss_data else None,
                        cvss_vector=cvss_data.get("vectorString") if cvss_data else None,
                        cve_ids=cve_ids,
                        cwe_ids=cwe_ids,
                        title=advisory.get("summary", ""),
                        description=advisory.get("description", ""),
                        published_date=advisory.get("publishedAt"),
                        modified_date=advisory.get("updatedAt"),
                        references=references,
                        aliases=[advisory.get("ghsaId", "")]
                    )
                    records.append(record)

                # Cache results
                self._cache[cache_key] = records
                self._cache_time[cache_key] = datetime.now()

                return records

        except Exception as e:
            logger.error(f"Error fetching GitHub advisories: {e}")
            return []


class OSVClient:
    """
    Client for OSV (Open Source Vulnerabilities) Database

    OSV is a distributed vulnerability database for open source.
    No authentication required.
    """

    API_ENDPOINT = "https://api.osv.dev/v1"

    def __init__(self):
        self._cache: Dict[str, List[VulnerabilityRecord]] = {}
        self._cache_time: Dict[str, datetime] = {}
        self._cache_duration = timedelta(hours=1)

    async def query_package(
        self,
        package_name: str,
        ecosystem: str,
        version: Optional[str] = None
    ) -> List[VulnerabilityRecord]:
        """
        Query OSV for vulnerabilities affecting a package.

        Args:
            package_name: Name of the package
            ecosystem: Package ecosystem
            version: Optional specific version to check

        Returns:
            List of VulnerabilityRecord objects
        """
        cache_key = f"{ecosystem}:{package_name}:{version or 'all'}"

        # Check cache
        if cache_key in self._cache:
            cache_time = self._cache_time.get(cache_key)
            if cache_time and datetime.now() - cache_time < self._cache_duration:
                return self._cache[cache_key]

        # Map ecosystems to OSV ecosystem names
        ecosystem_map = {
            "npm": "npm",
            "pip": "PyPI",
            "maven": "Maven",
            "gradle": "Maven",
            "composer": "Packagist",
            "bundler": "RubyGems",
            "go": "Go",
            "cargo": "crates.io",
            "nuget": "NuGet",
        }

        osv_ecosystem = ecosystem_map.get(ecosystem.lower())
        if not osv_ecosystem:
            return []

        # Build query
        query: Dict[str, Any] = {
            "package": {
                "name": package_name,
                "ecosystem": osv_ecosystem
            }
        }

        if version:
            query["version"] = version

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.post(
                    f"{self.API_ENDPOINT}/query",
                    json=query
                )

                if response.status_code != 200:
                    logger.error(f"OSV API error: {response.status_code}")
                    return []

                data = response.json()
                vulns = data.get("vulns", [])

                records = []
                for vuln in vulns:
                    # Extract affected versions
                    affected_versions = []
                    fixed_versions = []

                    for affected in vuln.get("affected", []):
                        for range_obj in affected.get("ranges", []):
                            for event in range_obj.get("events", []):
                                if "introduced" in event:
                                    affected_versions.append(f">={event['introduced']}")
                                if "fixed" in event:
                                    fixed_versions.append(event["fixed"])

                    # Extract severity
                    severity = "medium"
                    cvss_score = None
                    cvss_vector = None

                    for severity_obj in vuln.get("severity", []):
                        if severity_obj.get("type") == "CVSS_V3":
                            cvss_vector = severity_obj.get("score", "")
                            # Parse CVSS score from vector
                            if cvss_vector:
                                try:
                                    # Simple extraction of base score
                                    score_match = cvss_vector.split("/")
                                    if len(score_match) > 1:
                                        cvss_score = float(score_match[0].split(":")[-1]) if ":" in score_match[0] else None
                                except:
                                    pass

                    # Map severity from database severity if available
                    db_severity = vuln.get("database_specific", {}).get("severity", "")
                    if db_severity:
                        severity = db_severity.lower()
                    elif cvss_score:
                        if cvss_score >= 9.0:
                            severity = "critical"
                        elif cvss_score >= 7.0:
                            severity = "high"
                        elif cvss_score >= 4.0:
                            severity = "medium"
                        else:
                            severity = "low"

                    # Extract CWE IDs
                    cwe_ids = vuln.get("database_specific", {}).get("cwe_ids", [])

                    # Extract CVE aliases
                    aliases = vuln.get("aliases", [])
                    cve_ids = [a for a in aliases if a.startswith("CVE-")]

                    record = VulnerabilityRecord(
                        id=vuln.get("id", ""),
                        source=VulnerabilitySource.OSV,
                        package_name=package_name,
                        ecosystem=ecosystem,
                        affected_versions=affected_versions,
                        fixed_versions=fixed_versions,
                        severity=severity,
                        cvss_score=cvss_score,
                        cvss_vector=cvss_vector,
                        cve_ids=cve_ids,
                        cwe_ids=cwe_ids,
                        title=vuln.get("summary", ""),
                        description=vuln.get("details", ""),
                        published_date=vuln.get("published"),
                        modified_date=vuln.get("modified"),
                        references=[ref.get("url", "") for ref in vuln.get("references", [])],
                        aliases=aliases
                    )
                    records.append(record)

                # Cache results
                self._cache[cache_key] = records
                self._cache_time[cache_key] = datetime.now()

                return records

        except Exception as e:
            logger.error(f"Error querying OSV: {e}")
            return []

    async def get_vulnerability_by_id(self, vuln_id: str) -> Optional[VulnerabilityRecord]:
        """Fetch a specific vulnerability by ID from OSV."""
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(f"{self.API_ENDPOINT}/vulns/{vuln_id}")

                if response.status_code != 200:
                    return None

                vuln = response.json()

                # Parse similar to query_package
                affected_versions = []
                fixed_versions = []

                for affected in vuln.get("affected", []):
                    pkg = affected.get("package", {})
                    for range_obj in affected.get("ranges", []):
                        for event in range_obj.get("events", []):
                            if "introduced" in event:
                                affected_versions.append(f">={event['introduced']}")
                            if "fixed" in event:
                                fixed_versions.append(event["fixed"])

                aliases = vuln.get("aliases", [])
                cve_ids = [a for a in aliases if a.startswith("CVE-")]

                return VulnerabilityRecord(
                    id=vuln.get("id", ""),
                    source=VulnerabilitySource.OSV,
                    package_name=vuln.get("affected", [{}])[0].get("package", {}).get("name", ""),
                    ecosystem=vuln.get("affected", [{}])[0].get("package", {}).get("ecosystem", ""),
                    affected_versions=affected_versions,
                    fixed_versions=fixed_versions,
                    severity="medium",
                    cvss_score=None,
                    cvss_vector=None,
                    cve_ids=cve_ids,
                    cwe_ids=[],
                    title=vuln.get("summary", ""),
                    description=vuln.get("details", ""),
                    published_date=vuln.get("published"),
                    modified_date=vuln.get("modified"),
                    references=[ref.get("url", "") for ref in vuln.get("references", [])],
                    aliases=aliases
                )

        except Exception as e:
            logger.error(f"Error fetching OSV vulnerability {vuln_id}: {e}")
            return None


class NVDClient:
    """
    Client for NIST National Vulnerability Database (NVD)

    Uses NVD 2.0 API for vulnerability lookups.
    API key optional but recommended for higher rate limits.
    """

    API_ENDPOINT = "https://services.nvd.nist.gov/rest/json/cves/2.0"

    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.getenv("NVD_API_KEY", "")
        self._cache: Dict[str, List[VulnerabilityRecord]] = {}
        self._cache_time: Dict[str, datetime] = {}
        self._cache_duration = timedelta(hours=6)
        # Rate limiting: 5 requests/30s without key, 50/30s with key
        self._rate_delay = 0.1 if self.api_key else 0.7

    async def query_by_keyword(
        self,
        package_name: str,
        ecosystem: str,
        version: Optional[str] = None
    ) -> List[VulnerabilityRecord]:
        """
        Query NVD for vulnerabilities by keyword search.

        Args:
            package_name: Name of the package
            ecosystem: Package ecosystem (used for context)
            version: Optional version to filter results

        Returns:
            List of VulnerabilityRecord objects
        """
        cache_key = f"{ecosystem}:{package_name}:{version or 'all'}"

        # Check cache
        if cache_key in self._cache:
            cache_time = self._cache_time.get(cache_key)
            if cache_time and datetime.now() - cache_time < self._cache_duration:
                return self._cache[cache_key]

        try:
            async with httpx.AsyncClient(timeout=60.0) as client:
                headers = {}
                if self.api_key:
                    headers["apiKey"] = self.api_key

                # Build search query - use keywordSearch for package name
                params = {
                    "keywordSearch": package_name,
                    "resultsPerPage": 50
                }

                response = await client.get(
                    self.API_ENDPOINT,
                    headers=headers,
                    params=params
                )

                await asyncio.sleep(self._rate_delay)  # Rate limiting

                if response.status_code != 200:
                    logger.error(f"NVD API error: {response.status_code}")
                    return []

                data = response.json()
                vulns = data.get("vulnerabilities", [])

                records = []
                for vuln_item in vulns:
                    cve_data = vuln_item.get("cve", {})

                    # Extract CVE ID
                    cve_id = cve_data.get("id", "")

                    # Get descriptions
                    descriptions = cve_data.get("descriptions", [])
                    description = ""
                    for desc in descriptions:
                        if desc.get("lang") == "en":
                            description = desc.get("value", "")
                            break

                    # Skip if package name not in description (broad search results)
                    if package_name.lower() not in description.lower() and package_name.lower() not in cve_id.lower():
                        continue

                    # Extract CVSS metrics
                    metrics = cve_data.get("metrics", {})
                    cvss_score = None
                    cvss_vector = None
                    severity = "medium"

                    # Try CVSS v3.1 first, then v3.0, then v2.0
                    cvss_v31 = metrics.get("cvssMetricV31", [])
                    cvss_v30 = metrics.get("cvssMetricV30", [])
                    cvss_v2 = metrics.get("cvssMetricV2", [])

                    if cvss_v31:
                        cvss_data = cvss_v31[0].get("cvssData", {})
                        cvss_score = cvss_data.get("baseScore")
                        cvss_vector = cvss_data.get("vectorString")
                        severity = cvss_v31[0].get("baseSeverity", "MEDIUM").lower()
                    elif cvss_v30:
                        cvss_data = cvss_v30[0].get("cvssData", {})
                        cvss_score = cvss_data.get("baseScore")
                        cvss_vector = cvss_data.get("vectorString")
                        severity = cvss_v30[0].get("baseSeverity", "MEDIUM").lower()
                    elif cvss_v2:
                        cvss_data = cvss_v2[0].get("cvssData", {})
                        cvss_score = cvss_data.get("baseScore")
                        cvss_vector = cvss_data.get("vectorString")
                        # Map v2 severity
                        if cvss_score:
                            if cvss_score >= 9.0:
                                severity = "critical"
                            elif cvss_score >= 7.0:
                                severity = "high"
                            elif cvss_score >= 4.0:
                                severity = "medium"
                            else:
                                severity = "low"

                    # Extract CWE IDs
                    weaknesses = cve_data.get("weaknesses", [])
                    cwe_ids = []
                    for weakness in weaknesses:
                        for desc in weakness.get("description", []):
                            val = desc.get("value", "")
                            if val.startswith("CWE-"):
                                cwe_ids.append(val)

                    # Extract references
                    references = [
                        ref.get("url", "")
                        for ref in cve_data.get("references", [])
                    ][:10]  # Limit to 10 references

                    # Extract affected configurations for version info
                    affected_versions = []
                    configurations = cve_data.get("configurations", [])
                    for config in configurations:
                        for node in config.get("nodes", []):
                            for cpe_match in node.get("cpeMatch", []):
                                if cpe_match.get("vulnerable"):
                                    criteria = cpe_match.get("criteria", "")
                                    # Extract version info from CPE
                                    if package_name.lower() in criteria.lower():
                                        version_start = cpe_match.get("versionStartIncluding")
                                        version_end = cpe_match.get("versionEndExcluding")
                                        if version_start and version_end:
                                            affected_versions.append(f">={version_start},<{version_end}")
                                        elif version_end:
                                            affected_versions.append(f"<{version_end}")
                                        elif version_start:
                                            affected_versions.append(f">={version_start}")

                    record = VulnerabilityRecord(
                        id=cve_id,
                        source=VulnerabilitySource.NVD,
                        package_name=package_name,
                        ecosystem=ecosystem,
                        affected_versions=affected_versions if affected_versions else ["Check NVD for details"],
                        fixed_versions=[],
                        severity=severity,
                        cvss_score=cvss_score,
                        cvss_vector=cvss_vector,
                        cve_ids=[cve_id],
                        cwe_ids=cwe_ids,
                        title=f"{cve_id}: {description[:100]}..." if len(description) > 100 else f"{cve_id}: {description}",
                        description=description,
                        published_date=cve_data.get("published"),
                        modified_date=cve_data.get("lastModified"),
                        references=references,
                        aliases=[cve_id]
                    )
                    records.append(record)

                # Cache results
                self._cache[cache_key] = records
                self._cache_time[cache_key] = datetime.now()

                return records

        except Exception as e:
            logger.error(f"Error querying NVD: {e}")
            return []

    async def get_cve_details(self, cve_id: str) -> Optional[VulnerabilityRecord]:
        """Fetch details for a specific CVE from NVD."""
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                headers = {}
                if self.api_key:
                    headers["apiKey"] = self.api_key

                response = await client.get(
                    self.API_ENDPOINT,
                    headers=headers,
                    params={"cveId": cve_id}
                )

                await asyncio.sleep(self._rate_delay)

                if response.status_code != 200:
                    return None

                data = response.json()
                vulns = data.get("vulnerabilities", [])

                if not vulns:
                    return None

                cve_data = vulns[0].get("cve", {})

                # Extract description
                descriptions = cve_data.get("descriptions", [])
                description = ""
                for desc in descriptions:
                    if desc.get("lang") == "en":
                        description = desc.get("value", "")
                        break

                # Extract metrics
                metrics = cve_data.get("metrics", {})
                cvss_v31 = metrics.get("cvssMetricV31", [])
                cvss_score = None
                cvss_vector = None
                severity = "medium"

                if cvss_v31:
                    cvss_data = cvss_v31[0].get("cvssData", {})
                    cvss_score = cvss_data.get("baseScore")
                    cvss_vector = cvss_data.get("vectorString")
                    severity = cvss_v31[0].get("baseSeverity", "MEDIUM").lower()

                # Extract CWE IDs
                weaknesses = cve_data.get("weaknesses", [])
                cwe_ids = []
                for weakness in weaknesses:
                    for desc in weakness.get("description", []):
                        val = desc.get("value", "")
                        if val.startswith("CWE-"):
                            cwe_ids.append(val)

                return VulnerabilityRecord(
                    id=cve_id,
                    source=VulnerabilitySource.NVD,
                    package_name="",
                    ecosystem="",
                    affected_versions=[],
                    fixed_versions=[],
                    severity=severity,
                    cvss_score=cvss_score,
                    cvss_vector=cvss_vector,
                    cve_ids=[cve_id],
                    cwe_ids=cwe_ids,
                    title=f"{cve_id}",
                    description=description,
                    published_date=cve_data.get("published"),
                    modified_date=cve_data.get("lastModified"),
                    references=[ref.get("url", "") for ref in cve_data.get("references", [])[:10]],
                    aliases=[cve_id]
                )

        except Exception as e:
            logger.error(f"Error fetching CVE {cve_id} from NVD: {e}")
            return None


class SnykClient:
    """
    Client for Snyk Vulnerability Database

    Requires a Snyk API token for access.
    """

    API_ENDPOINT = "https://api.snyk.io/rest"

    def __init__(self, token: Optional[str] = None):
        self.token = token or os.getenv("SNYK_TOKEN", "")
        self._cache: Dict[str, List[VulnerabilityRecord]] = {}
        self._cache_time: Dict[str, datetime] = {}
        self._cache_duration = timedelta(hours=1)

    async def get_vulnerabilities_for_package(
        self,
        package_name: str,
        ecosystem: str,
        version: Optional[str] = None
    ) -> List[VulnerabilityRecord]:
        """
        Fetch vulnerabilities for a package from Snyk.

        Args:
            package_name: Name of the package
            ecosystem: Package ecosystem
            version: Optional specific version

        Returns:
            List of VulnerabilityRecord objects
        """
        cache_key = f"{ecosystem}:{package_name}:{version or 'all'}"

        # Check cache
        if cache_key in self._cache:
            cache_time = self._cache_time.get(cache_key)
            if cache_time and datetime.now() - cache_time < self._cache_duration:
                return self._cache[cache_key]

        if not self.token:
            logger.warning("Snyk token not configured, skipping Snyk lookup")
            return []

        # Map ecosystems to Snyk package types
        ecosystem_map = {
            "npm": "npm",
            "pip": "pip",
            "maven": "maven",
            "gradle": "maven",
            "composer": "composer",
            "bundler": "rubygems",
            "go": "golang",
            "cargo": "cargo",
            "nuget": "nuget",
        }

        snyk_ecosystem = ecosystem_map.get(ecosystem.lower())
        if not snyk_ecosystem:
            return []

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                # Snyk uses org-based API structure
                # This is a simplified query - real implementation would use full Snyk API
                headers = {
                    "Authorization": f"token {self.token}",
                    "Content-Type": "application/json"
                }

                # Query the issues endpoint
                # Note: This is a simplified representation - Snyk's actual API requires org context
                response = await client.post(
                    f"{self.API_ENDPOINT}/test/{snyk_ecosystem}/{package_name}",
                    headers=headers,
                    params={"version": version} if version else {}
                )

                if response.status_code != 200:
                    logger.debug(f"Snyk API returned {response.status_code} for {package_name}")
                    return []

                data = response.json()
                issues = data.get("issues", {}).get("vulnerabilities", [])

                records = []
                for issue in issues:
                    identifiers = issue.get("identifiers", {})
                    cve_ids = identifiers.get("CVE", [])
                    cwe_ids = identifiers.get("CWE", [])

                    record = VulnerabilityRecord(
                        id=issue.get("id", ""),
                        source=VulnerabilitySource.SNYK,
                        package_name=package_name,
                        ecosystem=ecosystem,
                        affected_versions=issue.get("semver", {}).get("vulnerable", []),
                        fixed_versions=[issue.get("fixedIn", [])] if issue.get("fixedIn") else [],
                        severity=issue.get("severity", "medium").lower(),
                        cvss_score=issue.get("cvssScore"),
                        cvss_vector=issue.get("CVSSv3"),
                        cve_ids=cve_ids,
                        cwe_ids=cwe_ids,
                        title=issue.get("title", ""),
                        description=issue.get("description", ""),
                        published_date=issue.get("publicationTime"),
                        modified_date=issue.get("modificationTime"),
                        references=issue.get("references", []),
                        aliases=[issue.get("id", "")]
                    )
                    records.append(record)

                # Cache results
                self._cache[cache_key] = records
                self._cache_time[cache_key] = datetime.now()

                return records

        except Exception as e:
            logger.error(f"Error fetching Snyk vulnerabilities: {e}")
            return []


class UnifiedVulnerabilityFeed:
    """
    Unified interface for querying multiple vulnerability databases.

    Aggregates results from GitHub Advisory, OSV, Snyk, and NVD,
    deduplicating based on CVE IDs and aliases.
    """

    def __init__(
        self,
        github_token: Optional[str] = None,
        snyk_token: Optional[str] = None,
        nvd_api_key: Optional[str] = None
    ):
        self.github_client = GitHubAdvisoryClient(github_token)
        self.osv_client = OSVClient()
        self.snyk_client = SnykClient(snyk_token)
        self.nvd_client = NVDClient(nvd_api_key)

        # Track which sources are available
        self.sources = {
            VulnerabilitySource.GITHUB_ADVISORY: bool(github_token or os.getenv("GITHUB_TOKEN")),
            VulnerabilitySource.OSV: True,  # OSV doesn't require auth
            VulnerabilitySource.SNYK: bool(snyk_token or os.getenv("SNYK_TOKEN")),
            VulnerabilitySource.NVD: True,  # NVD works without key (slower rate limit)
        }

    async def query_package(
        self,
        package_name: str,
        ecosystem: str,
        version: Optional[str] = None,
        sources: Optional[List[VulnerabilitySource]] = None
    ) -> List[VulnerabilityRecord]:
        """
        Query all configured vulnerability databases for a package.

        Args:
            package_name: Name of the package
            ecosystem: Package ecosystem
            version: Optional specific version to check
            sources: Optional list of sources to query (queries all by default)

        Returns:
            Deduplicated list of VulnerabilityRecord objects
        """
        if sources is None:
            sources = [s for s, enabled in self.sources.items() if enabled]

        tasks = []

        if VulnerabilitySource.GITHUB_ADVISORY in sources and self.sources.get(VulnerabilitySource.GITHUB_ADVISORY):
            tasks.append(self.github_client.get_advisories_for_package(package_name, ecosystem))

        if VulnerabilitySource.OSV in sources:
            tasks.append(self.osv_client.query_package(package_name, ecosystem, version))

        if VulnerabilitySource.SNYK in sources and self.sources.get(VulnerabilitySource.SNYK):
            tasks.append(self.snyk_client.get_vulnerabilities_for_package(package_name, ecosystem, version))

        if VulnerabilitySource.NVD in sources and self.sources.get(VulnerabilitySource.NVD):
            tasks.append(self.nvd_client.query_by_keyword(package_name, ecosystem, version))

        if not tasks:
            return []

        # Run all queries in parallel
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # Flatten and deduplicate results
        all_records: List[VulnerabilityRecord] = []
        seen_ids: Set[str] = set()

        for result in results:
            if isinstance(result, Exception):
                logger.error(f"Error in vulnerability query: {result}")
                continue

            for record in result:
                # Deduplicate by CVE IDs and source-specific IDs
                unique_key = self._get_unique_key(record)
                if unique_key not in seen_ids:
                    seen_ids.add(unique_key)
                    all_records.append(record)

        # Sort by severity
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        all_records.sort(key=lambda r: severity_order.get(r.severity, 4))

        return all_records

    async def batch_query(
        self,
        packages: Dict[str, str],  # package_name -> version
        ecosystem: str
    ) -> Dict[str, List[VulnerabilityRecord]]:
        """
        Query vulnerabilities for multiple packages in parallel.

        Args:
            packages: Dictionary mapping package names to versions
            ecosystem: Package ecosystem

        Returns:
            Dictionary mapping package names to their vulnerabilities
        """
        tasks = {
            pkg: self.query_package(pkg, ecosystem, version)
            for pkg, version in packages.items()
        }

        results = {}
        for pkg, task in tasks.items():
            try:
                results[pkg] = await task
            except Exception as e:
                logger.error(f"Error querying {pkg}: {e}")
                results[pkg] = []

        return results

    def _get_unique_key(self, record: VulnerabilityRecord) -> str:
        """Generate a unique key for deduplication."""
        pkg = record.package_name.lower() if record.package_name else ""

        # Prefer CVE ID with package name for specificity
        if record.cve_ids:
            cve = record.cve_ids[0]
            return f"{pkg}:{cve}" if pkg else cve

        # Fall back to source-specific ID with package
        return f"{pkg}:{record.source.value}:{record.id}"

    def get_available_sources(self) -> List[VulnerabilitySource]:
        """Get list of configured and available vulnerability sources."""
        return [s for s, enabled in self.sources.items() if enabled]


# Convenience functions for use in SCA scanner

async def check_package_vulnerabilities(
    package_name: str,
    version: str,
    ecosystem: str
) -> List[Dict[str, Any]]:
    """
    Check a single package for vulnerabilities across all available sources.

    Returns results in a format compatible with the existing SCA scanner.
    """
    feed = UnifiedVulnerabilityFeed()
    records = await feed.query_package(package_name, ecosystem, version)

    findings = []
    for record in records:
        findings.append({
            "package": record.package_name,
            "installed_version": version,
            "vulnerability": record.title,
            "cve": record.cve_ids[0] if record.cve_ids else record.id,
            "all_cves": record.cve_ids,
            "severity": record.severity,
            "cvss_score": record.cvss_score,
            "cwe_id": record.cwe_ids[0] if record.cwe_ids else "",
            "description": record.description,
            "remediation": f"Upgrade to {record.fixed_versions[0]}" if record.fixed_versions else "No fix available",
            "fixed_versions": record.fixed_versions,
            "published_date": record.published_date,
            "references": record.references,
            "source": record.source.value,
            "ecosystem": ecosystem
        })

    return findings


async def batch_check_vulnerabilities(
    dependencies: Dict[str, str],
    ecosystem: str
) -> Dict[str, Any]:
    """
    Check multiple packages for vulnerabilities.

    Returns aggregated results compatible with SCA scanner output.
    """
    feed = UnifiedVulnerabilityFeed()
    results = await feed.batch_query(dependencies, ecosystem)

    all_findings = []
    vulnerable_packages = 0
    severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}

    # Track seen findings to avoid duplicates
    seen_keys: set = set()

    for pkg, records in results.items():
        if records:
            vulnerable_packages += 1

        version = dependencies.get(pkg, "unknown")
        for record in records:
            # Create unique key for deduplication
            cve = record.cve_ids[0] if record.cve_ids else ""
            title_key = record.title[:50].lower() if record.title else ""
            pkg_lower = pkg.lower()

            # Check multiple dedup keys
            is_duplicate = False
            if cve:
                if cve in seen_keys or f"{pkg_lower}:{cve}" in seen_keys:
                    is_duplicate = True
            if title_key and f"{pkg_lower}:{title_key}" in seen_keys:
                is_duplicate = True

            if is_duplicate:
                continue

            # Add to seen
            if cve:
                seen_keys.add(cve)
                seen_keys.add(f"{pkg_lower}:{cve}")
            if title_key:
                seen_keys.add(f"{pkg_lower}:{title_key}")

            severity_counts[record.severity] = severity_counts.get(record.severity, 0) + 1
            all_findings.append({
                "package": record.package_name or pkg,  # Use original package name if not in record
                "installed_version": version,
                "vulnerability": record.title,
                "cve": cve or record.id,
                "all_cves": record.cve_ids,
                "severity": record.severity,
                "cvss_score": record.cvss_score,
                "cwe_id": record.cwe_ids[0] if record.cwe_ids else "",
                "description": record.description,
                "remediation": f"Upgrade to {record.fixed_versions[0]}" if record.fixed_versions else "No fix available",
                "fixed_versions": record.fixed_versions,
                "published_date": record.published_date,
                "references": record.references,
                "source": record.source.value,
                "ecosystem": ecosystem
            })

    return {
        "total_packages": len(dependencies),
        "vulnerable_packages": vulnerable_packages,
        "total_vulnerabilities": len(all_findings),
        "severity_counts": severity_counts,
        "findings": all_findings,
        "scan_date": datetime.now().isoformat(),
        "ecosystem": ecosystem,
        "sources": [s.value for s in feed.get_available_sources()]
    }


# Global instance
vulnerability_feed = UnifiedVulnerabilityFeed()
